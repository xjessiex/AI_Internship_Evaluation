---
title: "AI Internship Evaluation"
author: "Xiaoxuan (Jessie) Yang"
date: "1/3/2019"
output: pdf_document
---
# Set up
```{r setup, include=FALSE}
rm(list=ls())
knitr::opts_chunk$set(echo = TRUE)

# Install and load packages
# install.packages("tidyverse")
# install.packages("dplyr")
# install.packages("lubridate")
# install.packages("tm")



library("tm")
library("dplyr")
library("tidyverse")
library("tibble")
library("readr")
library("lubridate")


# Load the raw data
movie_data <- as_tibble(read_csv("~/Coding_AI/movie_data.csv",
                                   col_types = cols(
                                     id = col_integer(),
                                     title = col_character(),
                                     release_date = col_character(), # using col_date causes parsing failures
                                     box_office_revenue = col_double(),
                                     runtime = col_double(),
                                     genres = col_character(),
                                     summary = col_character()
                                    )
                                )
                        ) # using tibble to avoid converting strings to factors


# Check parsing failures
problems(movie_data) # parsing failure in the date column

dim(movie_data) # check dimension: 42204x7
```


# Data Preprocessing
```{r}
# Clean date 
  # Create a Year column
  movie_data[,"year"]<-year(as.Date(movie_data$release_date, "%Y",tryFormats = c("yyyy", "yyyy-mm-dd", "yyyy-mm")))

# Remove non-words components in the Summary column

  test="{{Plot|dateAct 1Act 2Act 3Act 4Act 5 Finally negotiations are made for Henry to be named king of both England and France. He has a brief romantic interlude with Catherine while the French and English royal delegations negotiate the Treaty of Troyes. The Greek chorus informs the audience that an English-French union lasted as long as Henry V lived and was only lost under his successor Henry VI."
  check<-removePunctuation(test)

# Eliminate missing values for the genres
  # check missing value for each column
  colSums(sapply(movie_data, is.na)) # genres has "[]" as the form of missing value
  
  # filter out empty cells in the genres column
  movie_data <- filter(movie_data, genres != "[]") 

# Remove duplicates
  # check duplicate rows
  sum(duplicated(movie_data)) # 0 

  # check duplicate summary--assumption: no films should share the same summary
  dedup.movie_data = movie_data[!duplicated(movie_data$summary),] 
  
  
dim(dedup.movie_data) # check dimension: 42196 x 8

data_final <- dedup.movie_data
```

# Genre Separation and Frequency
```{r}

# Clean the genre column
  # Eliminate the bracket in the genre column
    data_final$genres = gsub("\\[|\\]", "", data_final$genres)
  
  # Lower case
    data_final$genres = tolower(data_final$genres)
    
  # Eliminate space and convert two-word category into one-word
    data_final$genres = gsub(" ", "", data_final$genres ) # e.g. "romance film" -> "romancefilm"
  
  # Elimiate the comma
    data_final$genres = gsub(",", " ", data_final$genres)
    
# Create     
  genre <- Corpus(VectorSource(data_final$genres))
  genre_dtm <- DocumentTermMatrix(genre)
  
  genre_freq <- colSums(as.matrix(genre_dtm))
  freq <- sort(colSums(as.matrix(genre_dtm)), decreasing=TRUE) 
  genre_wf <- data.frame(word=names(genre_freq), freq=genre_freq)
```

# Popular genres based on box office revenue
```{r}

```

